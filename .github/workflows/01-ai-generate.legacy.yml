# .github/workflows/01-ai-generate.yml
name: Generate Website Configuration

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Describe your website'
        required: true
        type: string
      industry:
        description: 'Industry type'
        required: false
        type: string
        default: 'auto-detect'
      generate_images:
        description: 'Generate AI images'
        required: false
        type: boolean
        default: false
      freeform:
        description: 'Freeform mode (no block constraints; accept any schema)'
        required: false
        type: boolean
        default: false

  workflow_call:
    inputs:
      prompt:
        required: true
        type: string
      industry:
        required: false
        type: string
        default: 'auto-detect'
      generate_images:
        required: false
        type: boolean
        default: false
      freeform:
        required: false
        type: boolean
        default: false
    outputs:
      config_artifact:
        description: "Generated website configuration artifact name"
        value: website-config-${{ github.run_id }}

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # --- Allowed blocks: union of manual blocks-config.json and optional figma-blocks.json ---
      - name: Build allowed block list (manual ∪ figma)
        if: ${{ inputs.freeform != true }}
        id: allowed
        run: |
          set -euo pipefail
          MANUAL=$(jq -r '.blocks[]?.type' blocks-config.json 2>/dev/null | sort -u || true)
          if [ -f figma-blocks.json ]; then
            FIGMA=$(jq -r '.[].name' figma-blocks.json | sort -u)
          else
            FIGMA=""
          fi
          printf "%s\n%s\n" "$MANUAL" "$FIGMA" | awk 'NF' | sort -u | paste -sd',' - > allowed.txt
          echo "list=$(cat allowed.txt)" >> $GITHUB_OUTPUT

      - name: Generate website configuration
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          FREEFORM: ${{ inputs.freeform }}
        run: |
          set -euo pipefail

          echo "Prompt: ${{ inputs.prompt }}"
          echo "Industry: ${{ inputs.industry }}"
          echo "Generate images: ${{ inputs.generate_images }}"

          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "ERROR: OPENAI_API_KEY is not set"
            exit 1
          fi

          cat > system_prompt.txt << 'SYS_PROMPT'
          You are a senior UX designer and content strategist. Your job is to analyze the user's request and create a UNIQUE, custom website structure that perfectly fits their specific business needs.

          IMPORTANT: Make each site completely different! Vary the number of sections, content types, and layout based on what makes sense for that specific business.

          Available block types you can use:
          - hero: Hero section with title, subtitle, CTA, background image
          - features: Grid of feature cards (2-4 columns)
          - services: Service offerings in cards
          - testimonial: Single testimonial quote
          - testimonials: Multiple testimonials grid
          - cta: Call-to-action section
          - about: About us content
          - portfolio: Portfolio/gallery grid
          - team: Team member cards
          - pricing: Pricing tables
          - faq: Frequently asked questions
          - contact-form: Contact form section
          - stats: Statistics/numbers section
          - process: Step-by-step process
          - benefits: Benefits grid
          - locations: Multiple locations
          - menu: Restaurant/cafe menu
          - classes: Class schedules (yoga, fitness, etc)
          - gallery: Image gallery
          - blog-preview: Recent blog posts
          - newsletter: Email signup
          - social-proof: Logos/brands
          - two-col: Two column content
          - three-col: Three column content
          - full-width-text: Full width text section
          - video: Video section
          - map: Location map
          - hours: Business hours
          - booking: Appointment booking
            
          IMAGE-FRIENDLY BLOCK SHAPES, REQUIRED FIELDS:
          - hero: { title, subtitle, cta, image: "", overlay }  leave hero.image empty, it will be generated later
          - gallery: { title?, images: [ { alt: "meaningful description", url: "" }, ... ] }  always include 6–12 images with alt and leave url empty
          - team: { title?, members: [ { name, role, bio, photo: "" }, ... ] }  leave photo empty
          - services: { title?, items: [ { title, text, price?, icon: "" }, ... ] }  leave icon empty  

          DESIGN VARIETY RULES:
          1. Restaurants/Cafes: 6-10 sections (hero, menu, about, gallery, reviews, hours, contact)
          2. Yoga Studios: 4-7 sections (hero, classes, benefits, testimonials, pricing, contact)
          3. Law Firms: 5-8 sections (hero, services, about, team, testimonials, cta, contact)
          4. Photography: 4-6 sections (hero, portfolio, about, services, testimonials, contact)
          5. Consulting: 6-9 sections (hero, services, process, about, testimonials, stats, cta, contact)
          6. Medical: 5-8 sections (hero, services, about, team, hours, insurance, contact)
          7. Real Estate: 6-10 sections (hero, listings, services, about, testimonials, stats, contact)
          8. Retail: 5-9 sections (hero, products, about, benefits, reviews, cta, contact)

          Return ONLY valid JSON in this schema:
          {
            "slug": "unique-kebab-case-name",
            "name": "Creative Business Name",
            "tagline": "Compelling unique tagline",
            "industry": "detected-industry",
            "style": {
              "recipe": "minimal|editorial|brutalist|elegant|playful|tech",
              "variant": "a|b|c",
              "shapes": "squircle|angled|soft",
              "radius": 4|6|8|12|16,
              "elev": "low|med|high"
            },
            "brand": {
              "colors": {
                "primary": "#hex-color",
                "secondary": "#hex-color", 
                "accent": "#hex-color",
                "bg": "#hex-color",
                "text": "#hex-color"
              },
              "fonts": {
                "heading": "Google-Font-Name",
                "body": "Google-Font-Name"
              }
            },
            "hero": {
              "title": "Compelling headline specific to business",
              "subtitle": "Benefit-focused subtitle that's unique",
              "cta": {"label": "Action-oriented CTA", "href": "#contact"},
              "image": "",
              "overlay": 0.2-0.5
            },
            "pages": [
              {
                "slug": "home",
                "title": "Home", 
                "layout": "landing",
                "blocks": [
                  // CUSTOMIZE THIS ARRAY! Make it unique for each business type
                  // Use different combinations and quantities of blocks
                  // Write specific, engaging content for each block
                  {"type": "hero"},
                  // Add 3-12 more blocks that make sense for this specific business
                ]
              }
            ]
          }

          CONTENT RULES:
          - Write specific, engaging copy that sounds natural for that business type
          - Use industry-specific terminology and benefits
          - Make testimonials sound authentic with realistic names
          - Vary the number and types of sections dramatically between different prompts
          - Choose colors that match the industry and mood (warm for restaurants, professional for law, calming for yoga, etc.)
          - Use verified working Unsplash photo IDs from these categories:
            * Spa/Wellness: 1540979388821-28d9b8e4cf88, 1571019613454-1cb2f99b2d8b, 1506905925346-21bda4d32df4
            * Restaurant/Food: 1517248135467-4c7edcad34c4, 1504674900247-0877df9cc836, 1552566626-52f8b28a1ff1
            * Business/Office: 1497366216548-37526070297c, 1589829545856-d10d557cf95f, 1423666639041-f56206448028
            * Photography: 1452587925148-ce544e77e70d, 1606983340077-e4d9b3a5d6b9, 1516035069371-29a1b244cc32
            * Law/Professional: 1589829545856-d10d557cf95f, 1521737711867-e3b97375f902, 1560472354-b33ff0c44a5a
          - Use Google Fonts that match the business personality
          IMAGE PLACEHOLDER RULES:
          - Do not insert stock URLs for hero, gallery, team photos, or service icons
          - Always include the fields listed above and leave image URLs empty strings ""
          - Provide rich, specific alt text for each gallery image so a downstream process can generate accurate visuals
          - Write realistic people names and roles for team members so portraits can be generated
          - Do not use the Unsplash IDs list for hero, gallery, team photos, or service icons, leave those URLs empty; other blocks may still use stock images if needed.

          UNIQUENESS REQUIREMENTS:
          - No two sites should have the same section combination
          - Content should be specific to the business type and prompt
          - Visual style should vary significantly
          - Section order should make logical sense for that business
          - Always include hero first, contact/CTA toward the end
          SYS_PROMPT

          # In freeform mode, enforce exact output shape for Gutenberg content
          if [ "${FREEFORM}" = "true" ]; then
            cat > system_prompt.txt << 'EOF_FP'
          You are a precise content generator for WordPress Gutenberg pages.

          REQUIREMENTS (STRICT):
          - Return ONLY a single JSON object with exactly these root keys: "menu" and "pages". No other root keys are allowed.
          - Shape must be EXACTLY:
            {
              "menu": [ { "slug": "home", "title": "Home" }, ... ],
              "pages": [
                { "slug": "home",    "title": "Home",    "content_html": "<!-- wp:... --> ..." },
                { "slug": "about",   "title": "About",   "content_html": "<!-- wp:... --> ..." }
              ]
            }
          - Each page MUST include either:
            - "content_html": Gutenberg block HTML with standard block comments (e.g. "<!-- wp:paragraph -->"), OR
            - "blocks_raw": valid Gutenberg block JSON (the array/object structure understood by WordPress serialize_blocks). If you use blocks_raw, ensure it is valid for WordPress and serializable.
          - Include at least pages for "home" and "contact".
          - Do NOT include siteConfig, uniqueSections, contentSections, hero, brand, or any keys other than the two specified root keys. Keep the JSON minimal and focused.
          - Always write meaningful, business-specific copy inside Gutenberg blocks.

          OUTPUT RULES:
          - Output raw JSON only (no markdown fences, no comments).
          - Ensure the JSON parses and validates against the rules above.
          EOF_FP
          fi

          # Append strict allow-list of valid block types for the model
          if [ "${FREEFORM}" != "true" ]; then
            echo "\nValid block types you may use (strict): ${{ steps.allowed.outputs.list }}" >> system_prompt.txt
          fi

          SYSTEM_PROMPT=$(cat system_prompt.txt)
          USER_PROMPT="Create a unique website configuration for: ${{ inputs.prompt }}. Industry context: ${{ inputs.industry }}. Make this completely different from any other site - unique sections, content, and structure that perfectly fits this specific business."

          jq -n \
            --arg model "gpt-4o" \
            --arg system_content "$SYSTEM_PROMPT" \
            --arg user_content "$USER_PROMPT" \
            '{
              model: $model,
              response_format: {type: "json_object"},
              temperature: 1.1,
              max_tokens: 4000,
              messages: [
                {role: "system", content: $system_content},
                {role: "user", content: $user_content}
              ]
            }' > payload.json

          echo "Calling OpenAI API..."
          HTTP_CODE=$(curl -w "%{http_code}" -o api_response.json -s \
            -X POST "https://api.openai.com/v1/chat/completions" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload.json)

          echo "HTTP Status Code: $HTTP_CODE"

          USE_FALLBACK=false
          if [ "$HTTP_CODE" != "200" ]; then
            echo "API error"
            cat api_response.json || true
            USE_FALLBACK=true
          else
            if jq -e '.choices[0].message.content' api_response.json >/dev/null 2>&1; then
              jq -r '.choices[0].message.content' api_response.json > website.json || USE_FALLBACK=true
              if ! jq empty website.json >/dev/null 2>&1; then
                echo "Model returned invalid JSON"
                USE_FALLBACK=true
              fi
            else
              echo "No content in API response"
              USE_FALLBACK=true
            fi
          fi

          # Use legacy fallback only when not in freeform mode
          if [ "$USE_FALLBACK" = "true" ] && [ "${FREEFORM}" != "true" ]; then
            echo "Using fallback configuration"
            cat > website.json << 'JSON'
          {
            "slug": "unique-business-site",
            "name": "Custom Business",
            "tagline": "Tailored solutions for your needs", 
            "industry": "business",
            "brand": {
              "colors": {
                "primary": "#2563eb",
                "secondary": "#3b82f6", 
                "accent": "#1d4ed8",
                "bg": "#f8fafc",
                "text": "#111827"
              },
              "fonts": {
                "heading": "Inter",
                "body": "Inter"
              }
            },
            "hero": {
              "title": "Your Custom Business Solution",
              "subtitle": "Professionally crafted services",
              "cta": {"label": "Get Started", "href": "#contact"},
              "image": "",
              "overlay": 0.35
            },
            "pages": [
              {
                "slug": "home",
                "title": "Home",
                "layout": "landing", 
                "blocks": [
                  {"type": "hero"},
                  {"type": "features", "columns": 3, "items": [
                    {"title": "Quality Service", "text": "We deliver excellence in everything we do."},
                    {"title": "Fast Response", "text": "Quick turnaround times for all projects."},
                    {"title": "Expert Support", "text": "Professional guidance every step of the way."}
                  ]},
                  {"type": "about", "title": "About Us", "content": "We are dedicated professionals committed to your success."},
                  {"type": "testimonial", "quote": "Outstanding service and results!", "author": "Sarah Johnson"},
                  {"type": "cta", "text": "Ready to get started?", "button": {"label": "Contact Us", "href": "#contact"}},
                  {"type": "contact-form"}
                ]
              }
            ]
          }
          JSON
          fi

      - name: Validate freeform website.json has pages
        if: ${{ inputs.freeform == true }}
        run: |
          set -euo pipefail
          jq -e '
            .pages and (.pages | type=="array") and ((.pages | length) > 0) and
            ((.pages[] | has("slug") and has("title") and (has("content_html") or has("blocks_raw"))))
          ' website.json >/dev/null || {
            echo "::error::freeform website.json invalid: require pages[].{slug,title,content_html|blocks_raw}";
            exit 1;
          }

      # --- Enforce allowed block list on generated website.json ---
      - name: Enforce allowed block list
        if: ${{ inputs.freeform != true }}
        env:
          ALLOWED: ${{ steps.allowed.outputs.list }}
        run: |
          set -euo pipefail
          # Convert comma-separated list to JSON array, trimming whitespace and dropping empties
          ALLOWED_JSON=$(printf '%s' "$ALLOWED" | jq -R -s 'split(",") | map(gsub("^\\s+|\\s+$";"")) | map(select(length>0))')
          tmp=website.tmp.json
          jq --argjson allowed "$ALLOWED_JSON" '
            .pages |= ( . // [] ) | (.pages |= map(
              .blocks |= ( . // [] | map(select(.type as $t | $allowed | index($t))))
            ))
          ' website.json > "$tmp"
          mv "$tmp" website.json
      
      - name: Preview allowed types in website.json
        if: ${{ inputs.freeform != true }}
        run: |
          jq -r '[.pages[]?.blocks[]? | .type] | unique | sort | join(", ")' website.json

      - name: Validate and enhance generated config
        if: ${{ inputs.freeform != true }}
        run: |
          set -euo pipefail
          
          # Ensure required fields exist and add any missing defaults
          jq -S '
            .slug        //= ("generated-site-" + (now | tostring)) |
            .name        //= "Generated Business" |
            .tagline     //= "Professional services" |
            .industry    //= "business" |
            .style       //= {"recipe": "elegant", "variant": "a", "shapes": "soft", "radius": 8, "elev": "med"} |
            .brand.colors //= {"primary":"#2563eb","secondary":"#3b82f6","accent":"#1d4ed8","bg":"#f8fafc","text":"#111827"} |
            .brand.fonts  //= {"heading":"Inter","body":"Inter"} |
            .hero        //= {} |
            .hero.overlay //= 0.35 |
            .hero.image   //= "" |
            .pages       //= [{"slug":"home","title":"Home","layout":"landing","blocks":[{"type":"hero"}]}] |

            # Ensure home starts with hero
            (.pages |= map(
              if .slug == "home" and ((.blocks|length) > 0 and (.blocks[0].type != "hero")) 
                then .blocks = ([{"type":"hero"}] + .blocks) 
                else . end
            )) |

            # Ensure gallery, team, services placeholders exist and are shaped correctly
            (.pages |= map(
              .blocks |= map(
                if .type == "gallery" then
                  .images = ((.images // []) 
                    | map({
                        alt: (.alt // "Gallery image"),
                        url: (.url // "")
                      }))
                  | (if (.images|length) == 0 then
                      [{alt:"Gallery image 1",url:""},{alt:"Gallery image 2",url:""},{alt:"Gallery image 3",url:""}]
                    else . end)
                elif .type == "team" then
                  .members = ((.members // []) 
                    | map({
                        name: (.name // "Team Member"),
                        role: (.role // "Role"),
                        bio:  (.bio  // ""),
                        photo: (.photo // "")
                      }))
                elif .type == "services" then
                  .items = ((.items // [])
                    | map({
                        title: (.title // "Service"),
                        text:  (.text  // ""),
                        price: (.price // null),
                        icon:  (.icon  // "")
                      }))
                else .
                end
              )
            ))
          ' website.json > website.enhanced.json
          
          mv website.enhanced.json website.json

          echo "Enhanced website.json:"
          jq '.' website.json

          # Validate that we have a proper structure
          if ! jq -e '.pages[0].blocks | length >= 2' website.json >/dev/null; then
            echo "Warning: Generated config seems too simple, this might indicate AI generation issues"
          fi

      - name: Strip any prefilled image URLs if generating images
        if: ${{ inputs.freeform != true && inputs.generate_images == true }}
        run: |
          set -euo pipefail
          jq '
            .hero.image = "" |
            (.pages |= map(
              .blocks |= map(
                if .type == "gallery" then
                  .images = ((.images // []) | map(.url = "" | .))
                elif .type == "team" then
                  .members = ((.members // []) | map(.photo = "" | .))
                elif .type == "services" then
                  .items = ((.items // []) | map(.icon = "" | .))
                else .
                end
              )
            ))
          ' website.json > website.tmp.json
          mv website.tmp.json website.json

      - name: Authenticate to Google Cloud
        if: ${{ inputs.freeform != true && inputs.generate_images == true }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Setup Google Cloud SDK
        if: ${{ inputs.freeform != true && inputs.generate_images == true }}
        uses: google-github-actions/setup-gcloud@v2

      - name: Generate images using Google Vertex AI Imagen
        if: ${{ inputs.freeform != true && inputs.generate_images == true }}
        env:
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          CLOUDWAYS_HOST: ${{ secrets.CLOUDWAYS_HOST }}
          CLOUDWAYS_USER: ${{ secrets.CLOUDWAYS_USER }}
          CLOUDWAYS_SSH_KEY: ${{ secrets.CLOUDWAYS_SSH_KEY }}
          APP_PATH: ${{ secrets.APP_PATH }}
          SITEFUSE_WP_ORIGIN: ${{ vars.SITEFUSE_WP_ORIGIN }}
        run: |
          set -euo pipefail
          
          # Set up SSH key
          mkdir -p ~/.ssh
          echo "$CLOUDWAYS_SSH_KEY" | tr -d '\r' > ~/.ssh/cw_id
          chmod 600 ~/.ssh/cw_id
          
          # Verify SSH key format
          if ! ssh-keygen -l -f ~/.ssh/cw_id >/dev/null 2>&1; then
            echo "ERROR: SSH key format is invalid"
            echo "First few lines of key:"
            head -3 ~/.ssh/cw_id
            exit 1
          fi
          
          # Set up Google Cloud variables
          LOCATION="us-central1"
          MODEL="projects/${GCP_PROJECT_ID}/locations/${LOCATION}/publishers/google/models/imagen-3.0-generate-002"
          BUCKET="sitefuse-assets"
          ACCESS_TOKEN="$(gcloud auth print-access-token)"
          
          # Function to generate image using Vertex AI Imagen (matching your working version)
          gen_image() {
            local prompt="$1"
            local width="${2:-1600}"
            local height="${3:-800}"
          
            curl -sS \
              -H "Authorization: Bearer ${ACCESS_TOKEN}" \
              -H "Content-Type: application/json" \
              "https://${LOCATION}-aiplatform.googleapis.com/v1/${MODEL}:predict" \
              -d "{
                    \"instances\": [{ \"prompt\": \"${prompt//\"/\\\"}\" }],
                    \"parameters\": { \"sampleCount\": 1, \"sampleImageSize\": { \"width\": ${width}, \"height\": ${height} } }
                  }" \
            | jq -r '.predictions[0].bytesBase64Encoded' \
            | base64 -d
          }
          
          # gather context from website.json + workflow input
          SITE_NAME="$(jq -r '.name // ""' website.json)"
          HERO_TITLE="$(jq -r '.hero.title // ""' website.json)"
          HERO_SUB="$(jq -r '.hero.subtitle // ""' website.json)"

          RAW_PROMPT="${{ inputs.prompt }}"
          IND="${{ inputs.industry }}"

          # add controlled randomness for visual variety
          STYLES=(
            "abstract gradient background"
            "soft bokeh photography"
            "geometric pattern"
            "minimal textured backdrop"
            "calming nature scene"
            "architectural lines"
          )
          STYLE="${STYLES[$RANDOM % ${#STYLES[@]}]}"

          # build full prompt with strong anti-text cues
          FULL_PROMPT="$RAW_PROMPT, industry: $IND, site: $SITE_NAME, hero: $HERO_TITLE, $HERO_SUB, $STYLE, website hero background, clean modern design, no people, NO text, NO words, NO typography, NO letters, NO watermark, NO logo"

          # collapse newlines, escape quotes
          FULL_PROMPT="$(printf "%s" "$FULL_PROMPT" | tr '\n' ' ')"
          FULL_PROMPT_ESCAPED=${FULL_PROMPT//\"/\\\"}

          echo "Imagen prompt:"
          echo "$FULL_PROMPT"

          # ---- generate hero image ----
          echo "Generating hero image with Vertex AI Imagen..."
          gen_image "$FULL_PROMPT_ESCAPED" 1600 800 > hero.png
          
          # Check if image was generated successfully
          if [ -f "hero.png" ] && [ -s "hero.png" ]; then
            echo "Hero image generated successfully"
            ls -la hero.png
            
            # Upload to Google Cloud Storage
            STAMP=$(date +%s)
            echo "Uploading to Google Cloud Storage..."
            gcloud storage cp hero.png "gs://${BUCKET}/hero-${STAMP}.png" \
              --cache-control="public,max-age=31536000,immutable"

            # Also upload a stable alias (short cache) for safety/debug
            gcloud storage cp hero.png "gs://${BUCKET}/hero-latest.png" \
              --cache-control="public,max-age=60"

            # Create public URLs
            PUBLIC_URL="https://storage.googleapis.com/${BUCKET}/hero-${STAMP}.png"
            LATEST_URL="https://storage.googleapis.com/${BUCKET}/hero-latest.png"
            echo "Public URL:  $PUBLIC_URL"
            echo "Latest URL:  $LATEST_URL"

            # Verify object is readable, retry briefly if needed
            echo "Verifying GCS object availability..."
            ok=0
            for i in 1 2 3 4 5; do
              code=$(curl -s -o /dev/null -w "%{http_code}" "$PUBLIC_URL" || true)
              if [ "$code" = "200" ]; then ok=1; break; fi
              echo "Attempt $i: got $code, retrying..."; sleep 2
            done

            USE_URL="$PUBLIC_URL"
            if [ "$ok" != "1" ]; then
              echo "WARN: $PUBLIC_URL not readable yet; falling back to hero-latest.png"
              USE_URL="$LATEST_URL"
            fi

            # Upload hero image to WordPress uploads and point website.json there (Option A)
            echo "Uploading hero image to WordPress uploads (sitefuse)…"
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}" "
              set -e
              APP='${APP_PATH}'
              UPDIR=\"\$APP/wp-content/uploads/sitefuse\"
              mkdir -p \"\$UPDIR\"
            "
            rsync -az -e "ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id" hero.png "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}:${APP_PATH}/wp-content/uploads/sitefuse/hero-${STAMP}.png"
            rsync -az -e "ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id" hero.png "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}:${APP_PATH}/wp-content/uploads/sitefuse/hero-latest.png"

            # Ensure uploads dir exists (CORS handled elsewhere)
            :

            # Compute WP origin (use SITEFUSE_WP_ORIGIN if provided, else siteurl)
            WP_ORIGIN=""
            if [ -n "${SITEFUSE_WP_ORIGIN:-}" ]; then
              WP_ORIGIN="https://${SITEFUSE_WP_ORIGIN}"
            else
              WP_ORIGIN=$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}" "wp --path='${APP_PATH}' option get siteurl --allow-root" | sed 's#/*$##')
            fi

            # Base uploads URL
            WP_URL="${WP_ORIGIN}/wp-content/uploads/sitefuse/hero-latest.png"

            # Import into Media Library and get attachment URL
            echo "Importing hero image into WordPress Media Library…"
            ATTACH_ID=$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}" \
              "set -e; APP='${APP_PATH}'; wp --path=\"\$APP\" media import \"\$APP/wp-content/uploads/sitefuse/hero-${STAMP}.png\" --title='SiteFuse Hero ${STAMP}' --porcelain --allow-root" || true)

            MEDIA_URL=""
            if [ -n "$ATTACH_ID" ]; then
              # Avoid $argv expansion in outer shell by inlining the ID into PHP code
              MEDIA_URL=$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}" \
                "set -e; APP='${APP_PATH}'; wp --path=\"\$APP\" eval \"echo wp_get_attachment_url((int)${ATTACH_ID});\" --allow-root" || true)
            fi

            # Prefer Media URL if it validates; else fall back to uploads hero-latest.png
            USE_WP_URL="$WP_URL"
            if [ -n "$MEDIA_URL" ]; then
              echo "Verifying Media URL: $MEDIA_URL"
              HEADERS=$(curl -sI "$MEDIA_URL") || true
              if echo "$HEADERS" | grep -q " 200 " && echo "$HEADERS" | grep -qi "content-type: image/"; then
                USE_WP_URL="$MEDIA_URL"
              else
                echo "Media URL not valid image, falling back to hero-latest.png"
              fi
            fi

            # Verify chosen URL is an image
            echo "Verifying public image URL: $USE_WP_URL"
            HEADERS=$(curl -sI "$USE_WP_URL") || true
            echo "$HEADERS" | grep -q " 200 " || { echo "::error::Hero image URL not returning 200"; echo "$HEADERS"; exit 1; }
            echo "$HEADERS" | grep -qi "content-type: image/" || { echo "::error::Hero image URL not an image content-type"; echo "$HEADERS"; exit 1; }

            # Update website.json on Cloudways server to point to final URL
            echo "Updating website.json with hero image URL: $USE_WP_URL"
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/cw_id "${CLOUDWAYS_USER}@${CLOUDWAYS_HOST}" "
              set -e
              APP='${APP_PATH}'
              tmp=\"\$APP/website.tmp\"
              jq --arg url '${USE_WP_URL}' '.hero.image = \$url' \"\$APP/website.json\" > \"\$tmp\" && mv \"\$tmp\" \"\$APP/website.json\"
              wp --path=\"\$APP\" breeze purge --allow-root --cache=all || true
            "
            
            echo "Done! Hero image generated and deployed successfully"
          else
            echo "Failed to generate hero image"
            exit 1
          fi

      - name: Validate image generation results
        if: ${{ inputs.generate_images }}
        run: |
          set -euo pipefail
          
          echo "Checking image generation results..."
          
          # Count total expected vs populated images
          hero_expected=$(jq -r 'if .hero then 1 else 0 end' website.json)
          hero_populated=$(jq -r 'if .hero.image != "" and .hero.image != null then 1 else 0 end' website.json)
          
          gallery_expected=$(jq '[.pages[]?.blocks[]? | select(.type=="gallery") | .images[]?] | length' website.json)
          gallery_populated=$(jq '[.pages[]?.blocks[]? | select(.type=="gallery") | .images[]? | select(.url != "" and .url != null)] | length' website.json)
          
          team_expected=$(jq '[.pages[]?.blocks[]? | select(.type=="team") | .members[]?] | length' website.json)
          team_populated=$(jq '[.pages[]?.blocks[]? | select(.type=="team") | .members[]? | select(.photo != "" and .photo != null)] | length' website.json)
          
          services_expected=$(jq '[.pages[]?.blocks[]? | select(.type=="services") | .items[]?] | length' website.json)
          services_populated=$(jq '[.pages[]?.blocks[]? | select(.type=="services") | .items[]? | select(.icon != "" and .icon != null)] | length' website.json)
          
          echo "Image generation summary:"
          echo "Hero: $hero_populated/$hero_expected"
          echo "Gallery: $gallery_populated/$gallery_expected"
          echo "Team: $team_populated/$team_expected"
          echo "Services: $services_populated/$services_expected"
          
          total_expected=$((hero_expected + gallery_expected + team_expected + services_expected))
          total_populated=$((hero_populated + gallery_populated + team_populated + services_populated))
          
          echo "Total: $total_populated/$total_expected images generated"
          
          if [ "$total_populated" -lt "$total_expected" ]; then
            echo "Warning: Some images failed to generate, but continuing deployment..."
          else
          echo "All images generated successfully!"
          fi

      # --- Schema validation and filtering ---
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Enforce schema (filter unknown blocks)
        if: ${{ inputs.freeform != true }}
        run: |
          node tools/validate-website.mjs --in website.json --config blocks-config.json --out website.json

      - name: Freeform fallback — synthesize pages if missing
        if: ${{ inputs.freeform == true }}
        run: |
          set -euo pipefail
          HAS_PAGES=$(jq '((.pages // []) | length) > 0' website.json)
          if [ "$HAS_PAGES" = "true" ]; then
            echo "pages[] present; no synthesis required"; exit 0;
          fi
          echo "Synthesizing minimal pages/blocks from freeform spec…"
          jq '
            def slugify(s): (s//"" | ascii_downcase | gsub("[^a-z0-9]+";"-") | gsub("(^-|-$)";""));

            . as $doc |
            .name //= (.overview.name // .overview.title // .title // .businessName // "Your Business") |
            .tagline //= (.overview.tagline // .overview.subtitle // .mission // .tagline // "") |
            .hero = (.hero // { title: .name, subtitle: .tagline, image: "", overlay: 0.35 }) |
            ($doc.uniqueFeatures // $doc.features // []) as $features |
            ($doc.testimonials // $doc.quotes // []) as $tests |
            ($doc.services // $doc.offerings // []) as $servs |
            ($doc.cta // {}) as $cta |
            ($doc.navigation // $doc.nav // $doc.menu // []) as $nav |
            ($doc.gallery.images // []) as $galimgs |
            ($doc.faqs // []) as $faqs |
            ($doc.team.members // []) as $members |
            ($doc.pricing.tiers // []) as $tiers |
            ($doc.classes // $doc.schedule // []) as $classes |
            ($doc.menu.items // []) as $menuitems |
            
            .pages = (
              [
                {
                  slug: "home",
                  title: "Home",
                  layout: "landing",
                  blocks: (
                    [ { type:"hero", title: .hero.title, subtitle: .hero.subtitle, image: .hero.image, overlay: (.hero.overlay // 0.35), cta: $cta } ]
                    + (if ($features|length)>0 then [ { type:"features", title: "Features", items: ($features | map({ title: (.title // .name // .label // "Feature"), text: (.text // .description // "") })) } ] else [] end)
                    + (if ($servs|length)>0 then [ { type:"services", title: "Services", items: ($servs | map({ title: (.title // .name // "Service"), text: (.text // .description // ""), price: (.price // null) })) } ] else [] end)
                    + (if ($tests|length)>0 then [ { type:"testimonials", title: "Testimonials", items: ($tests | map({ quote: (.quote // .text // ""), author: (.author // .name // "Customer") })) } ] else [] end)
                    + [ { type:"cta", title: ($cta.title // null), text: ($cta.text // null), cta: { label: ($cta.label // "Get Started"), href: ($cta.href // $doc.cta.url // "#contact") } } ]
                  )
                }
              ]
              + (
                $nav | map(
                  ( .label // .title // .name // (if (type=="string") then . else "" end) ) as $lbl |
                  ($lbl | ascii_downcase) as $l |
                  {
                    slug: slugify($lbl),
                    title: $lbl,
                    layout: "default",
                    blocks: (
                      if ($l|test("about")) then [ { type:"two-col", title:"About Us", text: ($doc.about.text // $doc.overview.about // $doc.mission // "") } ]
                      elif ($l|test("service")) then ( if ($servs|length)>0 then [ { type:"services", title:"Services", items: ($servs | map({ title: (.title // .name // "Service"), text: (.text // .description // ""), price: (.price // null) })) } ] else [ { type:"services", title:"Services", items: [] } ] end )
                      elif ($l|test("contact")) then [ { type:"contact" }, { type:"cta", title: ($cta.title // "Get in touch"), text: ($cta.text // ""), cta: { label: ($cta.label // "Contact Us"), href: ($cta.href // "#contact") } } ]
                      elif ($l|test("gallery|portfolio")) then [ { type:"gallery", title:"Gallery", images: ($galimgs | map({ alt: (.alt // "Image"), url: (.url // "") })) } ]
                      elif ($l|test("blog|news|post")) then [ { type:"blog-preview", title:"Latest Posts" } ]
                      elif ($l|test("faq")) then [ { type:"faq", title:"FAQ", faqs: $faqs } ]
                      elif ($l|test("pricing|plans")) then [ { type:"pricing", title:"Pricing", tiers: $tiers } ]
                      elif ($l|test("team")) then [ { type:"team", title:"Our Team", members: $members } ]
                      elif ($l|test("class|schedule")) then [ { type:"classes", title:"Classes", items: $classes } ]
                      elif ($l|test("menu")) then [ { type:"menu", title:"Menu", items: $menuitems } ]
                      else [ { type:"full-width-text", title: $lbl, text: "" } ]
                      end
                    )
                  }
                )
              )
            )
          ' website.json > website.synth.json
          mv website.synth.json website.json

      - name: Upload configuration
        uses: actions/upload-artifact@v4
        with:
          name: website-config-${{ github.run_id }}
          path: website.json
          retention-days: 1

      - name: Publish to WordPress (SiteFuse Publisher)
        if: ${{ always() }}
        env:
          SITE_URL: ${{ secrets.SITE_URL }}
          PUBLISH_TOKEN: ${{ secrets.SITEFUSE_TOKEN_PUBLISH }}
        run: |
          set -euo pipefail
          if [ -z "${SITE_URL:-}" ]; then echo "::error::SITE_URL secret is not set"; exit 1; fi
          if [ -z "${PUBLISH_TOKEN:-}" ]; then echo "::error::SITEFUSE_TOKEN_PUBLISH secret is not set"; exit 1; fi
          URL="${SITE_URL%/}/wp-json/sitefuse/v1/publish"
          echo "Publishing website.json to $URL"
          # Attempt 1: application/json
          code=$(curl -s -o publish.out -w "%{http_code}" -X POST "$URL" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json; charset=utf-8" \
            -H "X-SF-Token: ${PUBLISH_TOKEN}" \
            --data-binary @website.json || true)
          echo "Attempt 1 -> HTTP $code" && cat publish.out || true
          if [ "$code" = "200" ]; then exit 0; fi
          # Attempt 2: text/plain
          echo "Retrying publish with text/plain…"
          code=$(curl -s -o publish.out -w "%{http_code}" -X POST "$URL" \
            -H "Accept: application/json" \
            -H "Content-Type: text/plain; charset=utf-8" \
            -H "X-SF-Token: ${PUBLISH_TOKEN}" \
            --data-binary @website.json || true)
          echo "Attempt 2 -> HTTP $code" && cat publish.out || true
          if [ "$code" = "200" ]; then exit 0; fi
          # Attempt 3: alt rest_route URL
          ALT="${SITE_URL%/}/?rest_route=/sitefuse/v1/publish"
          echo "Retrying publish via alt route…"
          code=$(curl -s -o publish.out -w "%{http_code}" -X POST "$ALT" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json; charset=utf-8" \
            -H "X-SF-Token: ${PUBLISH_TOKEN}" \
            --data-binary @website.json || true)
          echo "Attempt 3 -> HTTP $code" && cat publish.out || true
          if [ "$code" != "200" ]; then
            echo "::warning::Publish failed in Generate job (HTTP $code). Deploy job will retry."
          fi

      - name: Produce AI run summary
        if: ${{ always() }}
        run: |
          set -e
          mkdir -p run-summary
          PAGES=$(jq '(.pages // []) | length' website.json)
          BLOCKS=$(jq '[.pages[]? | (.blocks // []) | length] | add // 0' website.json)
          HERO_IMG=$(jq -r 'if (.hero // {} | .image // "") != "" then 1 else 0 end' website.json)
          jq -n \
            --arg mode "${{ inputs.freeform || false }}" \
            --argjson pages "$PAGES" \
            --argjson blocks "$BLOCKS" \
            --argjson hero_has_image "$HERO_IMG" \
            '{ai: {freeform: ($mode=="true"), pages: $pages, blocks: $blocks, hero_has_image: ($hero_has_image==1)}}' \
            > run-summary/ai.json
          tar -czf run-summary-ai.tgz -C run-summary ai.json

      - name: Upload run summary (AI)
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: run-summary-ai-${{ github.run_id }}
          path: |
            run-summary/ai.json
          retention-days: 3
